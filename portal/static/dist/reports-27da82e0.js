import { getToken } from './tokens.js';getToken('color-primary');async function fetchData(kind, startInput, endInput) {const params = new URLSearchParams();if (startInput.value) params.set('start', startInput.value);if (endInput.value) params.set('end', endInput.value);const resp = await fetch(`/reports/${kind}?${params.toString()}`);return resp.json();}function updateLinks(kind, startInput, endInput, csvLink, pdfLink) {const params = new URLSearchParams();params.set('kind', kind);if (startInput.value) params.set('start', startInput.value);if (endInput.value) params.set('end', endInput.value);params.set('type', 'csv');csvLink.href = `/reports/export?${params.toString()}`;params.set('type', 'pdf');pdfLink.href = `/reports/export?${params.toString()}`;}// Reading complianceconst readingStart = document.getElementById('reading-start');const readingEnd = document.getElementById('reading-end');const readingRate = document.getElementById('reading-rate');const readingCsv = document.getElementById('reading-csv');const readingPdf = document.getElementById('reading-pdf');async function updateReading() {readingRate.innerHTML = '<span class="placeholder col-6"></span>';const data = await fetchData('training', readingStart, readingEnd);const total = data.length;const passed = data.filter(r => r.passed).length;const rate = total ? Math.round((passed / total) * 100) : 0;readingRate.textContent = rate + '%';updateLinks('training', readingStart, readingEnd, readingCsv, readingPdf);}readingStart.addEventListener('change', updateReading);readingEnd.addEventListener('change', updateReading);updateReading();// Pending approval trendsconst trendStart = document.getElementById('trend-start');const trendEnd = document.getElementById('trend-end');const trendCsv = document.getElementById('trend-csv');const trendPdf = document.getElementById('trend-pdf');const trendChartCanvas = document.getElementById('trend-chart');const trendLoading = document.getElementById('trend-chart-loading');let trendChart;async function updateTrend() {trendChartCanvas.classList.add('d-none');trendLoading.classList.remove('d-none');const data = await fetchData('pending-approvals', trendStart, trendEnd);const counts = {};data.forEach(r => {const d = r.created_at.slice(0, 10);counts[d] = (counts[d] || 0) + 1;});const labels = Object.keys(counts).sort();const values = labels.map(l => counts[l]);if (trendChart) {trendChart.destroy();}trendChart = new Chart(trendChartCanvas, {type: 'line',data: {labels: labels,datasets: [{ label: 'Pending', data: values }]},});trendLoading.classList.add('d-none');trendChartCanvas.classList.remove('d-none');updateLinks('pending-approvals', trendStart, trendEnd, trendCsv, trendPdf);}trendStart.addEventListener('change', updateTrend);trendEnd.addEventListener('change', updateTrend);updateTrend();